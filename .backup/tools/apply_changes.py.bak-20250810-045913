from __future__ import annotations
import os, re, time, subprocess
from pathlib import Path
from typing import List, Tuple, Optional
from flask import Flask, request, jsonify

app = Flask(__name__)

# CORS básico
@app.after_request
def add_cors_headers(resp):
    resp.headers['Access-Control-Allow-Origin'] = '*'
    resp.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    resp.headers['Access-Control-Allow-Methods'] = 'POST, OPTIONS, GET'
    return resp

@app.route('/apply', methods=['OPTIONS'])
def apply_options():
    return ('', 204)

CURRENT_WORKSPACE_ROOT: Optional[Path] = None

# Marcadores / gramática
ACTION_RE   = re.compile(r'^#Action:\s*(FileNew|FileDelete|TextModify)\s*$', re.I)
TARGET_RE   = re.compile(r'^#Target:\s*(.+?)\s*$')
END_ACTION  = '#ActionEnded'

ANCHOR_BEG  = '#BeginAnchor'
ANCHOR_END  = '#EndAnchor'
CUT_BEG     = '#BeginCut'
CUT_END     = '#EndCut'
REPL_BEG    = '#BeginReplace'
REPL_END    = '#EndReplace'

SUBJ_BEG    = '#BeginSubject'
SUBJ_END    = '#EndSubject'

def _norm_inside(root: Path, target: str) -> Path:
    p = (root / target).resolve()
    if root not in p.parents and p != root:
        raise ValueError(f"Target escapes workspace: {p}")
    return p

def _read_block(lines: List[str], start_marker: str, end_marker: str) -> Tuple[List[str], int]:
    content = []
    i = 0
    while i < len(lines) and lines[i].strip() != start_marker:
        i += 1
    if i == len(lines):
        return [], -1
    i += 1
    while i < len(lines) and lines[i].strip() != end_marker:
        content.append(lines[i].rstrip('\r\n'))
        i += 1
    if i == len(lines):
        raise ValueError(f"Missing {end_marker}")
    i += 1
    return content, i

def _wrap_subject(s: str) -> str:
    if not s.startswith('\n'):
        s = '\n' + s
    if not s.endswith('\n'):
        s = s + '\n'
    return s

def _anchor_to_pattern(anchor_lines: List[str]) -> str:
    """Âncora tolera linhas em branco ENTRE linhas não vazias; captura como grupo 1."""
    nonblank = [ln for ln in anchor_lines if ln.strip() != ""]
    if not nonblank:
        return "()"  # âncora vazia (não recomendado) → match zero-largura
    sep = r"(?:[ \t]*\r?\n[ \t]*)*"
    parts = [re.escape(ln) for ln in nonblank]
    return "(" + sep.join(parts) + ")"

def _cut_to_strict_regex(cut_lines: List[str]) -> re.Pattern:
    """
    Cut: match EXATO de linhas contíguas (sem ignorar linhas em branco).
    Trabalhamos só com linhas inteiras; não editamos dentro da linha.
    Capturamos o bloco inteiro como grupo 1, incluindo fronteiras de linha.
    """
    if not cut_lines:
        return re.compile("()")
    esc = [re.escape(ln) for ln in cut_lines]
    body = r"(?:^|\n)" + r"\r?\n".join(esc) + r"(?:\r?\n|$)"
    return re.compile("(" + body + ")", re.DOTALL)

def _backup_dest(src: Path, root: Optional[Path], ts: str) -> Path:
    if root:
        try:
            rel = src.relative_to(root)
        except Exception:
            rel = Path(src.name)
        base = root / ".backup" / rel
    else:
        base = src.parent / ".backup" / src.name
    base.parent.mkdir(parents=True, exist_ok=True)
    return base.with_name(base.name + f".bak-{ts}")

def _parse_actions(proto_text: str):
    lines = [ln.rstrip('\r\n') for ln in proto_text.splitlines()]
    i = 0
    actions = []
    while i < len(lines):
        line = lines[i].strip()
        if not line:
            i += 1; continue
        m = ACTION_RE.match(line)
        if not m:
            i += 1; continue
        action = m.group(1)
        i += 1
        if i >= len(lines) or not TARGET_RE.match(lines[i].strip()):
            raise ValueError("Esperado '#Target:' após '#Action:'")
        target = TARGET_RE.match(lines[i].strip()).group(1)
        i += 1
        block_lines = []
        while i < len(lines) and lines[i].strip() != END_ACTION:
            block_lines.append(lines[i]); i += 1
        if i == len(lines):
            raise ValueError("Missing #ActionEnded")
        i += 1
        actions.append({"action": action, "target": target, "block_lines": block_lines})
    return actions

def _apply_filenew(file_path: Path, block_lines: List[str], log: List[str], ts: str):
    subject, _ = _read_block(block_lines, SUBJ_BEG, SUBJ_END)
    text = _wrap_subject("\n".join(subject))
    if file_path.exists():
        backup = _backup_dest(file_path, CURRENT_WORKSPACE_ROOT, ts)
        file_path.replace(backup)
        log.append(f"Backup existente: {backup}")
    file_path.parent.mkdir(parents=True, exist_ok=True)
    file_path.write_text(text, encoding="utf-8")
    log.append(f"FileNew OK: {file_path}")

def _apply_filedelete(file_path: Path, log: List[str], ts: str):
    if not file_path.exists():
        log.append(f"FileDelete: arquivo não existe ({file_path})")
        return
    backup = _backup_dest(file_path, CURRENT_WORKSPACE_ROOT, ts)
    file_path.replace(backup)
    log.append(f"FileDelete OK (arquivo movido para backup): {backup}")

def _apply_textmodify(file_path: Path, block_lines: List[str], log: List[str], ts: str):
    # Anchor (opcional), Cut (opcional/obrigatório sem âncora), Replace (obrigatório)
    anchor, _ = _read_block(block_lines, ANCHOR_BEG, ANCHOR_END)
    cut, _    = _read_block(block_lines, CUT_BEG, CUT_END)
    repl, _   = _read_block(block_lines, REPL_BEG, REPL_END)
    if not anchor and not cut:
        raise ValueError("TextModify requer Anchor ou Cut")
    if not repl:
        raise ValueError("TextModify requer Replace")

    original = file_path.read_text(encoding="utf-8")
    new_text = original
    insert_text = _wrap_subject("\n".join(repl))

    if anchor:
        # localizar âncora (tolerante a linhas em branco)
        anchor_pat = _anchor_to_pattern(anchor)
        anchor_re  = re.compile(anchor_pat, re.DOTALL)
        m_anchor   = anchor_re.search(new_text)
        if not m_anchor:
            log.append("[NÃO ACHADO] Âncora não encontrada")
            return
        anc_start, anc_end = m_anchor.span(1)
        anchor_real = new_text[anc_start:anc_end]  # sagrada
        right = new_text[anc_end:]

        if cut:
            cut_re = _cut_to_strict_regex(cut)
            m_cut = cut_re.search(right)
            if m_cut:
                c0, c1 = m_cut.span(1)
                right2 = right[:c0] + insert_text + right[c1:]
                new_text_final = new_text[:anc_start] + anchor_real + right2
                if new_text_final != original:
                    backup = _backup_dest(file_path, CURRENT_WORKSPACE_ROOT, ts)
                    backup.write_text(original, encoding="utf-8")
                    file_path.write_text(new_text_final, encoding="utf-8")
                    log.append(f"Backup do original: {backup}")
                    log.append("[OK] Cut encontrado e substituído por Replace (ancorado)")
                else:
                    log.append("Nenhuma alteração aplicada.")
            else:
                # Cut não encontrado após âncora -> inserir após âncora
                new_text_final = new_text[:anc_end] + insert_text + new_text[anc_end:]
                if new_text_final != original:
                    backup = _backup_dest(file_path, CURRENT_WORKSPACE_ROOT, ts)
                    backup.write_text(original, encoding="utf-8")
                    file_path.write_text(new_text_final, encoding="utf-8")
                    log.append(f"Backup do original: {backup}")
                    log.append("[INFO] Cut não encontrado; inserido Replace após âncora")
                else:
                    log.append("Nenhuma alteração aplicada.")
        else:
            # Só âncora -> inserir após âncora
            new_text_final = new_text[:anc_end] + insert_text + new_text[anc_end:]
            if new_text_final != original:
                backup = _backup_dest(file_path, CURRENT_WORKSPACE_ROOT, ts)
                backup.write_text(original, encoding="utf-8")
                file_path.write_text(new_text_final, encoding="utf-8")
                log.append(f"Backup do original: {backup}")
                log.append("[OK] Inserido Replace após âncora")
            else:
                log.append("Nenhuma alteração aplicada.")
    else:
        # Sem âncora: Cut obrigatório; substitui a primeira ocorrência global (linhas inteiras)
        cut_re = _cut_to_strict_regex(cut)
        m_cut = cut_re.search(new_text)
        if not m_cut:
            log.append("[NÃO ACHADO] Cut não encontrado (sem âncora)")
            return
        c0, c1 = m_cut.span(1)
        new_text_final = new_text[:c0] + insert_text + new_text[c1:]
        if new_text_final != original:
            backup = _backup_dest(file_path, CURRENT_WORKSPACE_ROOT, ts)
            backup.write_text(original, encoding="utf-8")
            file_path.write_text(new_text_final, encoding="utf-8")
            log.append(f"Backup do original: {backup}")
            log.append("[OK] Cut global substituído por Replace")
        else:
            log.append("Nenhuma alteração aplicada.")

@app.get("/status")
def status():
    from shutil import which
    conda_ok = bool(which("conda"))
    git_inited = bool(CURRENT_WORKSPACE_ROOT and (CURRENT_WORKSPACE_ROOT / ".git").exists())
    return jsonify({"ok": True, "server": "on", "conda_ok": conda_ok, "git_inited": git_inited})

def _run_git(args: List[str], cwd: Path) -> subprocess.CompletedProcess:
    return subprocess.run(["git"]+args, cwd=str(cwd), text=True, capture_output=True, shell=False)

@app.post("/git/init")
def git_init():
    data = request.get_json(force=True)
    root = Path(data.get("workspace_root",".")).resolve()
    name = data.get("name"); email = data.get("email")
    if not name or not email:
        return jsonify({"ok":False,"error":"name/email are required"}), 400
    r1 = _run_git(["init"], root)
    if r1.returncode != 0:
        return jsonify({"ok":False,"error":r1.stderr}), 500
    _run_git(["config","user.name",name], root)
    _run_git(["config","user.email",email], root)
    return jsonify({"ok":True,"output":r1.stdout})

@app.post("/git/commit")
def git_commit():
    data = request.get_json(force=True)
    root = Path(data.get("workspace_root",".")).resolve()
    message = data.get("message","update")
    do_push = bool(data.get("push", False))
    r_add = _run_git(["add","-A"], root)
    if r_add.returncode != 0:
        return jsonify({"ok":False,"error":r_add.stderr}), 500
    r_c = _run_git(["commit","-m",message], root)
    out = (r_add.stdout or "") + "\n" + (r_c.stdout or "")
    if r_c.returncode != 0:
        return jsonify({"ok":False,"error":r_c.stderr, "output":out}), 500
    if do_push:
        r_remote = _run_git(["remote"], root)
        if r_remote.stdout.strip():
            r_p = _run_git(["push"], root)
            out += "\n" + (r_p.stdout or "")
            if r_p.returncode != 0:
                return jsonify({"ok":False,"error":r_p.stderr, "output":out}), 500
        else:
            out += "\n(no remote configured; skipping push)"
    return jsonify({"ok":True,"output":out})

@app.post("/restart")
def restart():
    os._exit(0)

@app.post("/apply")
def apply_changes():
    data = request.get_json(force=True)
    workspace_root = Path(data.get("workspace_root", ".")).resolve()
    protocol_text = data.get("protocol_text", "")
    out_lines: List[str] = []

    global CURRENT_WORKSPACE_ROOT
    CURRENT_WORKSPACE_ROOT = workspace_root

    ts = time.strftime("%Y%m%d-%H%M%S")
    actions = _parse_actions(protocol_text)

    for a in actions:
        act = a["action"]; target = a["target"]; blocks = a["block_lines"]
        out_lines.append(f"=> Log/print Action File Inicio: {act} {target}")
        try:
            file_path = _norm_inside(workspace_root, target)
            if act.lower() == "filenew":
                _apply_filenew(file_path, blocks, out_lines, ts)
            elif act.lower() == "filedelete":
                _apply_filedelete(file_path, out_lines, ts)
            elif act.lower() == "textmodify":
                if not file_path.exists():
                    raise FileNotFoundError(f"Arquivo não encontrado: {file_path}")
                _apply_textmodify(file_path, blocks, out_lines, ts)
            else:
                out_lines.append(f"[ERRO] Ação não suportada: {act}")
        except Exception as e:
            out_lines.append(f"[ERRO] {e}")
        out_lines.append("")
    out = "\n".join(out_lines) if out_lines else "Nada aplicado."
    return jsonify({"ok": True, "output": out})

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--host", default="127.0.0.1")
    parser.add_argument("--port", default=5000, type=int)
    args = parser.parse_args()
    print(f"* Servindo em http://{args.host}:{args.port}  (POST /apply)")
    app.run(host=args.host, port=args.port)
    
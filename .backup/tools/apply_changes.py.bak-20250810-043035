# apply_changes.py — Protocolo ÚNICO (ACR) + FileNew/FileDelete
# - Âncora “sagrada” (intocável) com busca tolerante a linhas em branco
# - Cut opcional
# - Replace com \n no início e no fim
# - Backups em .backup/<relpath>.bak-YYYYmmdd-HHMMSS
# - Endpoints: /apply, /status, /restart, /git/init, /git/commit
from __future__ import annotations
import os, re, time, subprocess
from pathlib import Path
from typing import List, Tuple, Optional
from flask import Flask, request, jsonify

app = Flask(__name__)

# --- CORS básico: autoriza chamadas do updater.html (file://) para http://localhost:5000 ---
@app.after_request
def add_cors_headers(resp):
    resp.headers['Access-Control-Allow-Origin'] = '*'
    resp.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    resp.headers['Access-Control-Allow-Methods'] = 'POST, OPTIONS, GET'
    return resp

@app.route('/apply', methods=['OPTIONS'])
def apply_options():
    return ('', 204)

CURRENT_WORKSPACE_ROOT: Optional[Path] = None

# Protocolo Único
ACTION_RE   = re.compile(r'^#Action:\s*(FileNew|FileDelete|TextModify)\s*$', re.I)
TARGET_RE   = re.compile(r'^#Target:\s*(.+?)\s*$')
END_ACTION  = '#ActionEnded'

# Marcadores ACR
ANCHOR_BEG  = '#BeginAnchor'
ANCHOR_END  = '#EndAnchor'
CUT_BEG     = '#BeginCut'
CUT_END     = '#EndCut'
REPL_BEG    = '#BeginReplace'
REPL_END    = '#EndReplace'
# FileNew subject
SUBJ_BEG    = '#BeginSubject'
SUBJ_END    = '#EndSubject'

def _norm_inside(root: Path, target: str) -> Path:
    p = (root / target).resolve()
    if root not in p.parents and p != root:
        raise ValueError(f"Target escapes workspace: {p}")
    return p

def _read_block(lines: List[str], start_marker: str, end_marker: str) -> Tuple[List[str], int]:
    """Lê bloco (mantém linhas como estão), retorna (conteúdo, offset a partir do início de 'lines').
       Se start não for encontrado, retorna ([], -1)."""
    content = []
    i = 0
    while i < len(lines) and lines[i].strip() != start_marker:
        i += 1
    if i == len(lines):
        return [], -1
    i += 1
    while i < len(lines) and lines[i].strip() != end_marker:
        # preserva linha crua (sem \r\n finais)
        content.append(lines[i].rstrip('\r\n'))
        i += 1
    if i == len(lines):
        raise ValueError(f"Missing {end_marker}")
    i += 1
    return content, i

def _wrap_subject(s: str) -> str:
    """Garante \n no início e no fim do subject/replace para não colar no entorno."""
    out = s
    if not out.startswith('\n'):
        out = '\n' + out
    if not out.endswith('\n'):
        out = out + '\n'
    return out

def _anchor_to_pattern(anchor_lines: List[str]) -> str:
    """Gera regex tolerante a linhas em branco ENTRE as linhas não-vazias da âncora."""
    nonblank = [ln for ln in anchor_lines if ln.strip() != ""]
    if not nonblank:
        # âncora vazia: não recomendamos, mas consideramos match zero-largura
        return r"()"
    sep = r"(?:[ \t]*\r?\n[ \t]*)*"
    parts = [re.escape(ln) for ln in nonblank]
    # capturamos âncora inteira como grupo 1
    return "(" + sep.join(parts) + ")"

def _cut_to_pattern(cut_lines: List[str]) -> str:
    nonblank = [ln for ln in cut_lines if ln.strip() != ""]
    if not nonblank:
        # cut vazio: também vira grupo (pouco usual)
        return "(" + r"" + ")"
    sep = r"(?:[ \t]*\r?\n[ \t]*)*"
    parts = [re.escape(ln) for ln in nonblank]
    return "(" + sep.join(parts) + ")"

def _backup_dest(src: Path, root: Optional[Path], ts: str) -> Path:
    """Destino .backup preservando estrutura relativa a partir do root."""
    if root:
        try:
            rel = src.relative_to(root)
        except Exception:
            rel = Path(src.name)
        base = root / ".backup" / rel
    else:
        base = src.parent / ".backup" / src.name
    base.parent.mkdir(parents=True, exist_ok=True)
    return base.with_name(base.name + f".bak-{ts}")

def _parse_protocol(proto_text: str):
    """Quebra o protocolo em ações."""
    lines = [ln.rstrip('\r\n') for ln in proto_text.splitlines()]
    i = 0
    actions = []
    while i < len(lines):
        line = lines[i].strip()
        if not line:
            i += 1; continue
        m = ACTION_RE.match(line)
        if not m:
            i += 1; continue
        action = m.group(1)
        i += 1
        if i >= len(lines) or not TARGET_RE.match(lines[i].strip()):
            raise ValueError("Esperado '#Target:' após '#Action:'")
        target = TARGET_RE.match(lines[i].strip()).group(1)
        i += 1

        # coletar blocos até #ActionEnded
        block_lines = []
        while i < len(lines) and lines[i].strip() != END_ACTION:
            block_lines.append(lines[i])
            i += 1
        if i == len(lines):
            raise ValueError("Missing #ActionEnded")
        i += 1  # pula #ActionEnded

        actions.append({"action": action, "target": target, "block_lines": block_lines})
    return actions

def _apply_filenew(file_path: Path, block_lines: List[str], log: List[str], ts: str):
    # Lê Subject
    subject, _ = _read_block(block_lines, SUBJ_BEG, SUBJ_END)
    text = "\n".join(subject)
    text = _wrap_subject(text)
    if file_path.exists():
        backup = _backup_dest(file_path, CURRENT_WORKSPACE_ROOT, ts)
        file_path.replace(backup)
        log.append(f"Backup existente: {backup}")
    file_path.parent.mkdir(parents=True, exist_ok=True)
    file_path.write_text(text, encoding="utf-8")
    log.append(f"FileNew OK: {file_path}")

def _apply_filedelete(file_path: Path, log: List[str], ts: str):
    if not file_path.exists():
        log.append(f"FileDelete: arquivo não existe ({file_path})")
        return
    backup = _backup_dest(file_path, CURRENT_WORKSPACE_ROOT, ts)
    file_path.replace(backup)
    log.append(f"FileDelete OK (arquivo movido para backup): {backup}")

def _apply_textmodify(file_path: Path, block_lines: List[str], log: List[str], ts: str):
    # Blocos ACR
    anchor, off = _read_block(block_lines, ANCHOR_BEG, ANCHOR_END)
    if off == -1 or not anchor:
        raise ValueError("TextModify requer bloco Anchor")
    cut, off2 = _read_block(block_lines, CUT_BEG, CUT_END)
    replace, off3 = _read_block(block_lines, REPL_BEG, REPL_END)
    if off3 == -1:
        raise ValueError("TextModify requer bloco Replace")

    original = file_path.read_text(encoding="utf-8")
    new_text = original

    # Regex tolerante com captura das porções reais para preservar bytes originais
    anchor_pat = _anchor_to_pattern(anchor)
    cut_pat    = _cut_to_pattern(cut) if cut else None

    # Encontrar âncora
    # Estrutura: (ÂNCORA_TOLERANTE)(?P<mid>.*?)(DEMAIS)
    # Depois, dentro do trecho após âncora, buscamos CUT tolerante.
    anchor_re = re.compile(anchor_pat, re.DOTALL)
    m_anchor = anchor_re.search(new_text)
    if not m_anchor:
        log.append("[NÃO ACHADO] Âncora não encontrada")
        return

    # Fatias
    anc_start, anc_end = m_anchor.span(1)
    anchor_real = new_text[anc_start:anc_end]  # bytes reais da âncora, preservados

    right_side = new_text[anc_end:]  # após âncora
    insert_text = _wrap_subject("\n".join(replace))

    replaced_right = None
    if cut and cut_pat:
        cut_re = re.compile(cut_pat, re.DOTALL)
        m_cut = cut_re.search(right_side)
        if m_cut:
            c_start, c_end = m_cut.span(1)
            # substitui o CUT por Replace
            replaced_right = right_side[:c_start] + insert_text + right_side[c_end:]
            log.append("[OK] Cut encontrado e substituído por Replace")
        else:
            log.append("[INFO] Cut não encontrado; inserido Replace após âncora")
    if replaced_right is None:
        # Inserir Replace logo após âncora
        replaced_right = insert_text + right_side

    # Monta texto final preservando âncora intocada
    new_text_final = new_text[:anc_start] + anchor_real + replaced_right

    if new_text_final != original:
        backup = _backup_dest(file_path, CURRENT_WORKSPACE_ROOT, ts)
        backup.write_text(original, encoding="utf-8")
        file_path.write_text(new_text_final, encoding="utf-8")
        log.append(f"Backup do original: {backup}")
        log.append("[OK] TextModify aplicado (ACR)")
    else:
        log.append("Nenhuma alteração aplicada.")

@app.get("/status")
def status():
    from shutil import which
    conda_ok = bool(which("conda"))
    git_inited = bool(CURRENT_WORKSPACE_ROOT and (CURRENT_WORKSPACE_ROOT / ".git").exists())
    return jsonify({"ok": True, "server": "on", "conda_ok": conda_ok, "git_inited": git_inited})

def _run_git(args: List[str], cwd: Path) -> subprocess.CompletedProcess:
    return subprocess.run(["git"]+args, cwd=str(cwd), text=True, capture_output=True, shell=False)

@app.post("/git/init")
def git_init():
    data = request.get_json(force=True)
    root = Path(data.get("workspace_root",".")).resolve()
    name = data.get("name"); email = data.get("email")
    if not name or not email:
        return jsonify({"ok":False,"error":"name/email are required"}), 400
    r1 = _run_git(["init"], root)
    if r1.returncode != 0:
        return jsonify({"ok":False,"error":r1.stderr}), 500
    _run_git(["config","user.name",name], root)
    _run_git(["config","user.email",email], root)
    return jsonify({"ok":True,"output":r1.stdout})

@app.post("/git/commit")
def git_commit():
    data = request.get_json(force=True)
    root = Path(data.get("workspace_root",".")).resolve()
    message = data.get("message","update")
    do_push = bool(data.get("push", False))
    r_add = _run_git(["add","-A"], root)
    if r_add.returncode != 0:
        return jsonify({"ok":False,"error":r_add.stderr}), 500
    r_c = _run_git(["commit","-m",message], root)
    out = (r_add.stdout or "") + "\n" + (r_c.stdout or "")
    if r_c.returncode != 0:
        return jsonify({"ok":False,"error":r_c.stderr, "output":out}), 500
    if do_push:
        r_remote = _run_git(["remote"], root)
        if r_remote.stdout.strip():
            r_p = _run_git(["push"], root)
            out += "\n" + (r_p.stdout or "")
            if r_p.returncode != 0:
                return jsonify({"ok":False,"error":r_p.stderr, "output":out}), 500
        else:
            out += "\n(no remote configured; skipping push)"
    return jsonify({"ok":True,"output":out})

@app.post("/restart")
def restart():
    os._exit(0)

@app.post("/apply")
def apply_changes():
    data = request.get_json(force=True)
    workspace_root = Path(data.get("workspace_root", ".")).resolve()
    protocol_text = data.get("protocol_text", "")
    out_lines: List[str] = []

    global CURRENT_WORKSPACE_ROOT
    CURRENT_WORKSPACE_ROOT = workspace_root

    ts = time.strftime("%Y%m%d-%H%M%S")
    actions = _parse_protocol(protocol_text)

    for a in actions:
        act = a["action"]; target = a["target"]; blocks = a["block_lines"]
        out_lines.append(f"=> Log/print Action File Inicio: {act} {target}")
        try:
            file_path = _norm_inside(workspace_root, target)
            if act.lower() == "filenew":
                _apply_filenew(file_path, blocks, out_lines, ts)
            elif act.lower() == "filedelete":
                _apply_filedelete(file_path, out_lines, ts)
            elif act.lower() == "textmodify":
                if not file_path.exists():
                    raise FileNotFoundError(f"Arquivo não encontrado: {file_path}")
                _apply_textmodify(file_path, blocks, out_lines, ts)
            else:
                out_lines.append(f"[ERRO] Ação não suportada: {act}")
        except Exception as e:
            out_lines.append(f"[ERRO] {e}")
        out_lines.append("")
    out = "\n".join(out_lines) if out_lines else "Nada aplicado."
    return jsonify({"ok": True, "output": out})

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--host", default="127.0.0.1")
    parser.add_argument("--port", default=5000, type=int)
    args = parser.parse_args()
    print(f"* Servindo em http://{args.host}:{args.port}  (POST /apply)")
    app.run(host=args.host, port=args.port)
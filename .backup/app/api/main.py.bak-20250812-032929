
from __future__ import annotations
import os, sqlite3, time, json, base64, hashlib
from collections import deque
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Optional, Deque, Dict, Tuple, List

from fastapi import FastAPI, HTTPException, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, PlainTextResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
from passlib.hash import bcrypt
import jwt
from dotenv import load_dotenv

# ------------------------ Config ------------------------
load_dotenv()

BASE_DIR = Path(__file__).resolve().parents[2]
DATA_DIR = BASE_DIR / "data"
DB_PATH  = DATA_DIR / "app.db"
SEC_LOG  = DATA_DIR / "security.log"
RL_FILE  = DATA_DIR / "rate_limits.json"
IP_FILE  = DATA_DIR / "ip_lists.json"
DATA_DIR.mkdir(parents=True, exist_ok=True)

SECRET_KEY = os.getenv("FASTAPI_SECRET", os.getenv("FASTAPI_SECRET_KEY", "CHANGE-ME-SECRET"))
ALGO = "HS256"

def _int(env, default):
    try: return int(os.getenv(env, str(default)))
    except: return default

# Defaults (podem ser alterados via /api/admin/rate_limits)
DEFAULT_RL = {
    "login_max":   _int("RATE_LIMIT_LOGIN_ATTEMPTS",   5),
    "login_win":   _int("RATE_LIMIT_LOGIN_WINDOW_SEC", 600),
    "signup_max":  _int("RATE_LIMIT_SIGNUP_ATTEMPTS",  5),
    "signup_win":  _int("RATE_LIMIT_SIGNUP_WINDOW_SEC",600),
    "reset_max":   _int("RATE_LIMIT_RESET_ATTEMPTS",   5),
    "reset_win":   _int("RATE_LIMIT_RESET_WINDOW_SEC", 300),
    "distinct_max": _int("RATE_LIMIT_DISTINCT_USERS_MAX", 5),
    "distinct_win": _int("RATE_LIMIT_DISTINCT_USERS_WINDOW_SEC", 600),
}
SECURITY_LOG_ENABLE  = os.getenv("SECURITY_LOG_ENABLE", "true").lower() in ("1","true","yes","on")
DEV_ALLOW_SEED_ADMIN = os.getenv("DEV_ALLOW_SEED_ADMIN", "false").lower() in ("1","true","yes","on")
DEV_SHOW_RESET_TOKEN = os.getenv("DEV_SHOW_RESET_TOKEN", "false").lower() in ("1","true","yes","on")

ACCESS_TOKEN_EXPIRE_HOURS = _int("ACCESS_TOKEN_EXPIRE_HOURS", 8)
REFRESH_TOKEN_EXPIRE_DAYS = _int("REFRESH_TOKEN_EXPIRE_DAYS", 7)

# Rate limit JSON
def load_rate_limits() -> dict:
    if RL_FILE.exists():
        try:
            data = json.loads(RL_FILE.read_text(encoding="utf-8"))
            return {**DEFAULT_RL, **{k:int(v) for k,v in data.items() if k in DEFAULT_RL}}
        except Exception:
            pass
    return DEFAULT_RL.copy()

def save_rate_limits(cfg: dict) -> None:
    RL_FILE.write_text(json.dumps({k:int(cfg[k]) for k in DEFAULT_RL}, indent=2), encoding="utf-8")

RL = load_rate_limits()

# IP allow/deny JSON
def load_ip_lists() -> dict:
    if IP_FILE.exists():
        try:
            data = json.loads(IP_FILE.read_text(encoding="utf-8"))
            allow = [s.strip() for s in data.get("allow", []) if s.strip()]
            deny  = [s.strip() for s in data.get("deny", [])  if s.strip()]
            return {"allow": allow, "deny": deny}
        except Exception:
            pass
    return {"allow": [], "deny": []}

def save_ip_lists(cfg: dict) -> None:
    allow = [str(x).strip() for x in cfg.get("allow", []) if str(x).strip()]
    deny  = [str(x).strip() for x in cfg.get("deny", [])  if str(x).strip()]
    IP_FILE.write_text(json.dumps({"allow": allow, "deny": deny}, indent=2), encoding="utf-8")

IPCFG = load_ip_lists()

# ------------------------ App --------------------------
app = FastAPI(title="DoneApp API", openapi_url="/api/openapi.json", docs_url="/api/docs")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

WEB_DIR = BASE_DIR / "app" / "web"
WEB_DIR.mkdir(parents=True, exist_ok=True)
app.mount("/web", StaticFiles(directory=str(WEB_DIR), html=True), name="web")
app.include_router(oauth_google_router)


@app.get("/", include_in_schema=False)
def root_index():
    return FileResponse(WEB_DIR / "index.html")

# ------------------------ DB ---------------------------
def get_db() -> sqlite3.Connection:
    conn = sqlite3.connect(str(DB_PATH))
    conn.execute("PRAGMA foreign_keys = ON")
    return conn

def init_db():
    conn = get_db()
    try:
        conn.executescript("""
        CREATE TABLE IF NOT EXISTS users (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          username TEXT UNIQUE NOT NULL,
          password_hash TEXT NOT NULL,
          created_at TEXT NOT NULL,
          role TEXT NOT NULL DEFAULT 'user'
        );

        CREATE TABLE IF NOT EXISTS integrations (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          owner TEXT NOT NULL,
          provider TEXT NOT NULL,
          account_label TEXT NOT NULL,
          status TEXT NOT NULL DEFAULT 'active',
          created_at TEXT NOT NULL,
          FOREIGN KEY(owner) REFERENCES users(username) ON DELETE CASCADE
        );

        CREATE TABLE IF NOT EXISTS integration_secrets (
          integration_id INTEGER PRIMARY KEY,
          secret_enc TEXT NOT NULL,
          updated_at TEXT NOT NULL,
          FOREIGN KEY(integration_id) REFERENCES integrations(id) ON DELETE CASCADE
        );
        """)
        conn.commit()
    finally:
        conn.close()

def run_migrations():
    conn = get_db()
    try:
        cols = {r[1] for r in conn.execute("PRAGMA table_info(users)").fetchall()}
        if "role" not in cols:
            conn.execute("ALTER TABLE users ADD COLUMN role TEXT NOT NULL DEFAULT 'user'")
            conn.commit()
        # tables de integrações já são criadas em init_db()
    finally:
        conn.close()

init_db()
run_migrations()

# ------------------------ Schemas ----------------------
class SignUp(BaseModel):
    username: str
    password: str

class Login(BaseModel):
    username: str
    password: str

class RefreshIn(BaseModel):
    refresh_token: str

class ChangePasswordIn(BaseModel):
    current_password: str
    new_password: str

class SeedAdminIn(BaseModel):
    username: str

class ResetRequestIn(BaseModel):
    username: str

class ResetConfirmIn(BaseModel):
    token: str
    new_password: str

class RateLimitsIn(BaseModel):
    login_max: Optional[int] = None
    login_win: Optional[int] = None
    signup_max: Optional[int] = None
    signup_win: Optional[int] = None
    reset_max: Optional[int] = None
    reset_win: Optional[int] = None
    distinct_max: Optional[int] = None
    distinct_win: Optional[int] = None

class IpListsIn(BaseModel):
    allow: Optional[List[str]] = None
    deny: Optional[List[str]] = None

# Integrações
class IntegrationCreate(BaseModel):
    provider: str
    account_label: str
    token: str

class IntegrationRotate(BaseModel):
    token: str

# ------------------------ Security utils -----------------
_RL_BUCKETS: Dict[str, Deque[float]] = {}
_RL_DISTINCT: Dict[str, Deque[Tuple[float, str]]] = {}

def client_ip(req: Request) -> str:
    xf = (req.headers.get("x-forwarded-for") or "").split(",")[0].strip()
    if xf: return xf
    return req.client.host if req.client else "unknown"

def sec_log(action: str, status: str, user: str = "", ip: str = "", extra: str = ""):
    if not SECURITY_LOG_ENABLE: return
    try:
        DATA_DIR.mkdir(parents=True, exist_ok=True)
        with SEC_LOG.open("a", encoding="utf-8") as f:
            ts = datetime.utcnow().isoformat() + "Z"
            f.write(f"{ts} action={action} status={status} user={user} ip={ip} {extra}\n")
    except Exception:
        pass

def _bucket(key: str) -> Deque[float]:
    return _RL_BUCKETS.setdefault(key, deque())

def rate_limit(key: str, max_attempts: int, window_sec: int) -> Optional[int]:
    now = time.time()
    dq = _bucket(key)
    while dq and now - dq[0] > window_sec:
        dq.popleft()
    if len(dq) >= max_attempts:
        retry_after = int(window_sec - (now - dq[0])) + 1
        return max(1, retry_after)
    dq.append(now)
    return None

def account_switch_block(ip: str, username: str) -> Optional[int]:
    now = time.time()
    win = RL["distinct_win"]
    mx  = RL["distinct_max"]
    dq  = _RL_DISTINCT.setdefault(ip, deque())
    while dq and now - dq[0][0] > win:
        dq.popleft()
    distinct = {}
    for ts, user in dq:
        if now - ts <= win:
            distinct[user] = ts
    if username not in distinct and len(distinct) >= mx:
        oldest = min(distinct.values())
        retry_after = int(win - (now - oldest)) + 1
        return max(1, retry_after)
    return None

def account_switch_register(ip: str, username: str) -> None:
    now = time.time()
    dq = _RL_DISTINCT.setdefault(ip, deque())
    dq.append((now, username))

def ip_allowed(ip: str) -> bool:
    if any(ip == d or (d.endswith(".*") and ip.startswith(d[:-1])) for d in IPCFG["deny"]):
        return False
    allow = IPCFG.get("allow", [])
    if not allow:
        return True
    return any(ip == a or (a.endswith(".*") and ip.startswith(a[:-1])) for a in allow)

def enforce_ip_or_403(ip: str):
    if not ip_allowed(ip):
        raise HTTPException(status_code=403, detail="IP not allowed")

# ------------------------ Crypto helpers ----------------
def fernet():
    # Deriva uma chave de 32 bytes do SECRET_KEY (não é KDF forte, é DEV-friendly)
    from cryptography.fernet import Fernet
    h = hashlib.sha256(SECRET_KEY.encode("utf-8")).digest()
    k = base64.urlsafe_b64encode(h)
    return Fernet(k)

def enc_token(plain: str) -> str:
    return fernet().encrypt(plain.encode("utf-8")).decode("utf-8")

def dec_token(token_enc: str) -> str:
    return fernet().decrypt(token_enc.encode("utf-8")).decode("utf-8")

# ------------------------ Auth helpers -----------------
def create_access_token(sub: str, role: str, expires: Optional[timedelta] = None) -> str:
    now = datetime.now(timezone.utc)
    exp = now + (expires or timedelta(hours=ACCESS_TOKEN_EXPIRE_HOURS))
    payload = {"sub": sub, "role": role, "type": "access", "iat": int(now.timestamp()), "exp": int(exp.timestamp())}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGO)

def create_refresh_token(sub: str) -> str:
    now = datetime.now(timezone.utc)
    exp = now + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    payload = {"sub": sub, "type": "refresh", "iat": int(now.timestamp()), "exp": int(exp.timestamp())}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGO)

def create_reset_token(sub: str) -> str:
    now = datetime.now(timezone.utc)
    exp = now + timedelta(minutes=30)
    payload = {"sub": sub, "type": "reset", "iat": int(now.timestamp()), "exp": int(exp.timestamp())}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGO)

def verify_password(pw: str, pw_hash: str) -> bool:
    try: return bcrypt.verify(pw, pw_hash)
    except: return False

def get_current_user(request: Request) -> str:
    auth = request.headers.get("Authorization") or ""
    if not auth.lower().startswith("bearer "):
        raise HTTPException(status_code=401, detail="Missing token")
    token = auth.split(" ",1)[1].strip()
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGO])
        if payload.get("type") != "access":
            raise HTTPException(status_code=401, detail="Invalid token type")
        sub = payload.get("sub")
        if not sub: raise HTTPException(status_code=401, detail="Invalid token payload")
        return str(sub)
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except Exception:
        raise HTTPException(status_code=401, detail="Invalid token")

def get_user_role(username: str) -> str:
    conn = get_db()
    try:
        row = conn.execute("SELECT role FROM users WHERE username=?", (username,)).fetchone()
        return row[0] if row else "user"
    finally:
        conn.close()

def require_admin(user: str = Depends(get_current_user)) -> str:
    if get_user_role(user) != "admin":
        raise HTTPException(status_code=403, detail="Admin only")
    return user

# ------------------------ Routes: Auth core -----------------------
@app.post("/api/signup")
def api_signup(body: SignUp, request: Request):
    ip = client_ip(request)
    enforce_ip_or_403(ip)
    ra = rate_limit(f"signup:{ip}", RL["signup_max"], RL["signup_win"])
    if ra:
        sec_log("signup_rate_limited", "blocked", ip=ip)
        raise HTTPException(status_code=429, detail="Too many signup attempts", headers={"Retry-After": str(ra)})

    if not body.username or not body.password:
        raise HTTPException(status_code=400, detail="Missing username/password")
    conn = get_db()
    try:
        pw_hash = bcrypt.hash(body.password)
        conn.execute(
            "INSERT INTO users (username, password_hash, created_at) VALUES (?, ?, ?)",
            (body.username, pw_hash, datetime.utcnow().isoformat()+"Z"),
        )
        conn.commit()
        sec_log("signup", "ok", user=body.username, ip=ip)
        return {"ok": True}
    except sqlite3.IntegrityError:
        sec_log("signup", "username_taken", user=body.username, ip=ip)
        raise HTTPException(status_code=400, detail="Username already exists")
    finally:
        conn.close()

@app.post("/api/login")
def api_login(body: Login, request: Request):
    ip = client_ip(request)
    enforce_ip_or_403(ip)
    ra = rate_limit(f"login:{ip}", RL["login_max"], RL["login_win"])
    if ra:
        sec_log("login_rate_limited", "blocked", user=body.username, ip=ip)
        raise HTTPException(status_code=429, detail="Too many login attempts", headers={"Retry-After": str(ra)})

    conn = get_db()
    try:
        row = conn.execute("SELECT password_hash, role FROM users WHERE username = ?", (body.username,)).fetchone()
        if not row or not verify_password(body.password, row[0]):
            sec_log("login", "invalid", user=body.username, ip=ip)
            raise HTTPException(status_code=401, detail="Invalid credentials")

        ra2 = account_switch_block(ip, body.username)
        if ra2:
            sec_log("login_switch_block", "blocked", user=body.username, ip=ip, extra=f"distinct>{RL['distinct_max']}")
            raise HTTPException(status_code=429, detail="Too many different users from this IP", headers={"Retry-After": str(ra2)})

        role = row[1] or "user"
        access  = create_access_token(sub=body.username, role=role)
        refresh = create_refresh_token(sub=body.username)
        account_switch_register(ip, body.username)
        sec_log("login", "ok", user=body.username, ip=ip, extra=f"role={role}")
        return {"access_token": access, "refresh_token": refresh, "token_type": "bearer", "role": role}
    finally:
        conn.close()

@app.post("/api/token/refresh")
def token_refresh(body: RefreshIn, request: Request):
    ip = client_ip(request)
    enforce_ip_or_403(ip)
    try:
        payload = jwt.decode(body.refresh_token, SECRET_KEY, algorithms=[ALGO])
        if payload.get("type") != "refresh":
            raise HTTPException(status_code=401, detail="Invalid token type")
        sub = str(payload.get("sub") or "")
        if not sub: raise HTTPException(status_code=401, detail="Invalid refresh token")
        conn = get_db()
        try:
            row = conn.execute("SELECT role FROM users WHERE username=?", (sub,)).fetchone()
            role = (row[0] if row else "user")
        finally:
            conn.close()
        return {"access_token": create_access_token(sub=sub, role=role), "token_type": "bearer"}
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Refresh token expired")
    except Exception:
        raise HTTPException(status_code=401, detail="Invalid refresh token")

@app.post("/api/reset/request")
def reset_request(body: ResetRequestIn, request: Request):
    ip = client_ip(request)
    enforce_ip_or_403(ip)
    ra = rate_limit(f"reset:{ip}", RL["reset_max"], RL["reset_win"])
    if ra:
        sec_log("reset_request_rate_limited", "blocked", user=body.username, ip=ip)
        raise HTTPException(status_code=429, detail="Too many reset attempts", headers={"Retry-After": str(ra)})

    user = body.username.strip()
    if not user:
        raise HTTPException(status_code=400, detail="username required")
    conn = get_db()
    try:
        row = conn.execute("SELECT 1 FROM users WHERE username=?", (user,)).fetchone()
        if not row:
            sec_log("reset_request", "unknown_user", user=user, ip=ip)
            return {"ok": True}
    finally:
        conn.close()
    token = create_reset_token(sub=user)
    sec_log("reset_request", "ok", user=user, ip=ip)
    if DEV_SHOW_RESET_TOKEN:
        return {"ok": True, "reset_token": token}
    return {"ok": True}

@app.post("/api/reset/confirm")
def reset_confirm(body: ResetConfirmIn, request: Request):
    ip = client_ip(request)
    enforce_ip_or_403(ip)
    try:
        payload = jwt.decode(body.token, SECRET_KEY, algorithms=[ALGO])
        if payload.get("type") != "reset":
            sec_log("reset_confirm", "bad_type", ip=ip)
            raise HTTPException(status_code=401, detail="Invalid token type")
        user = str(payload.get("sub") or "")
        if not user:
            sec_log("reset_confirm", "no_sub", ip=ip)
            raise HTTPException(status_code=401, detail="Invalid token")
    except jwt.ExpiredSignatureError:
        sec_log("reset_confirm", "expired", ip=ip)
        raise HTTPException(status_code=401, detail="Reset token expired")
    except Exception:
        sec_log("reset_confirm", "invalid", ip=ip)
        raise HTTPException(status_code=401, detail="Invalid reset token")

    if not body.new_password:
        raise HTTPException(status_code=400, detail="new_password required")

    conn = get_db()
    try:
        new_hash = bcrypt.hash(body.new_password)
        updated = conn.execute("UPDATE users SET password_hash=? WHERE username=?", (new_hash, user)).rowcount
        conn.commit()
        if updated == 0:
            sec_log("reset_confirm", "user_not_found", user=user, ip=ip)
            raise HTTPException(status_code=404, detail="User not found")
        sec_log("reset_confirm", "ok", user=user, ip=ip)
        return {"ok": True}
    finally:
        conn.close()

@app.get("/api/me")
def api_me(user: str = Depends(get_current_user)):
    return {"user": user}

@app.get("/api/users/me")
def users_me(user: str = Depends(get_current_user)):
    conn = get_db()
    try:
        row = conn.execute("SELECT username, role, created_at FROM users WHERE username=?", (user,)).fetchone()
        if not row: raise HTTPException(status_code=404, detail="User not found")
        return {"username": row[0], "role": row[1], "created_at": row[2]}
    finally:
        conn.close()

@app.post("/api/change_password")
def change_password(body: ChangePasswordIn, user: str = Depends(get_current_user), request: Request = None):
    conn = get_db()
    try:
        row = conn.execute("SELECT password_hash FROM users WHERE username=?", (user,)).fetchone()
        if not body.current_password or not body.new_password or not row or not verify_password(body.current_password, row[0]):
            if request is not None:
                sec_log("change_password", "invalid_current", user=user, ip=client_ip(request))
            raise HTTPException(status_code=401, detail="Invalid current password")
        new_hash = bcrypt.hash(body.new_password)
        conn.execute("UPDATE users SET password_hash=? WHERE username=?", (new_hash, user))
        conn.commit()
        if request is not None:
            sec_log("change_password", "ok", user=user, ip=client_ip(request))
        return {"ok": True}
    finally:
        conn.close()

# ------------------------ Admin: RL, IP, Logs -----------------------
@app.get("/api/admin/ping")
def admin_ping(user: str = Depends(require_admin), request: Request = None):
    if request is not None:
        sec_log("admin_ping", "ok", user=user, ip=client_ip(request))
    return {"admin": user, "ok": True}

@app.get("/api/admin/rate_limits")
def get_rate_limits(_: str = Depends(require_admin)):
    return RL

@app.post("/api/admin/rate_limits")
def set_rate_limits(body: RateLimitsIn, user: str = Depends(require_admin)):
    changed = {}
    for k, v in body.dict().items():
        if v is None: continue
        if k in DEFAULT_RL:
            try:
                RL[k] = int(v)
                changed[k] = RL[k]
            except Exception:
                raise HTTPException(status_code=400, detail=f"invalid value for {k}")
    if changed:
        save_rate_limits(RL)
        sec_log("rate_limits", "updated", user=user, extra=json.dumps(changed))
    return {"ok": True, "config": RL}

@app.get("/api/admin/ip_lists")
def get_ip_lists(_: str = Depends(require_admin)):
    return IPCFG

@app.post("/api/admin/ip_lists")
def set_ip_lists(body: IpListsIn, user: str = Depends(require_admin)):
    global IPCFG
    allow = [s.strip() for s in (body.allow or []) if s and s.strip()]
    deny  = [s.strip() for s in (body.deny  or []) if s and s.strip()]
    IPCFG = {"allow": allow, "deny": deny}
    save_ip_lists(IPCFG)
    sec_log("ip_lists", "updated", user=user, extra=json.dumps(IPCFG))
    return {"ok": True, "config": IPCFG}

@app.get("/api/admin/security_log")
def security_log_tail(lines: int = 200, _: str = Depends(require_admin)):
    if not SEC_LOG.exists():
        return PlainTextResponse("", media_type="text/plain")
    try:
        text = SEC_LOG.read_text(encoding="utf-8", errors="ignore")
        rows = text.splitlines()[-max(1, min(10000, lines)):]
        return PlainTextResponse("\n".join(rows), media_type="text/plain")
    except Exception:
        raise HTTPException(status_code=500, detail="cannot read log")

@app.get("/api/admin/security_log/download")
def security_log_download(_: str = Depends(require_admin)):
    if not SEC_LOG.exists():
        return PlainTextResponse("", media_type="text/plain")
    return FileResponse(str(SEC_LOG), filename="security.log", media_type="text/plain")

@app.post("/api/admin/security_log/clear")
def security_log_clear(user: str = Depends(require_admin)):
    try:
        if SEC_LOG.exists():
            SEC_LOG.unlink()
        sec_log("security_log", "cleared", user=user)
        return {"ok": True}
    except Exception:
        raise HTTPException(status_code=500, detail="cannot clear log")

# ------------------------ Integrações -----------------------
def _must_be_owner_or_admin(request_user: str, owner: str):
    role = get_user_role(request_user)
    if request_user != owner and role != "admin":
        raise HTTPException(status_code=403, detail="Forbidden")

@app.post("/api/integrations")
def create_integration(body: IntegrationCreate, user: str = Depends(get_current_user), request: Request = None):
    ip = client_ip(request) if request else ""
    if not body.provider or not body.account_label or not body.token:
        raise HTTPException(status_code=400, detail="Missing fields")
    now = datetime.utcnow().isoformat()+"Z"
    conn = get_db()
    try:
        cur = conn.execute(
            "INSERT INTO integrations (owner, provider, account_label, status, created_at) VALUES (?, ?, ?, 'active', ?)",
            (user, body.provider.strip(), body.account_label.strip(), now)
        )
        iid = cur.lastrowid
        conn.execute(
            "INSERT INTO integration_secrets (integration_id, secret_enc, updated_at) VALUES (?, ?, ?)",
            (iid, enc_token(body.token), now)
        )
        conn.commit()
        sec_log("integration_create", "ok", user=user, ip=ip, extra=f"id={iid}, provider={body.provider}")
        return {"ok": True, "id": iid}
    finally:
        conn.close()

@app.get("/api/integrations")
def list_integrations(user: str = Depends(get_current_user), request: Request = None, all: int = 0):
    ip = client_ip(request) if request else ""
    conn = get_db()
    try:
        if all and get_user_role(user) == "admin":
            rows = conn.execute("SELECT id, owner, provider, account_label, status, created_at FROM integrations ORDER BY id DESC").fetchall()
        else:
            rows = conn.execute("SELECT id, owner, provider, account_label, status, created_at FROM integrations WHERE owner=? ORDER BY id DESC", (user,)).fetchall()
        data = [dict(id=r[0], owner=r[1], provider=r[2], account_label=r[3], status=r[4], created_at=r[5]) for r in rows]
        sec_log("integration_list", "ok", user=user, ip=ip, extra=f"count={len(data)}")
        return {"items": data}
    finally:
        conn.close()

def _get_integration(conn, iid: int):
    row = conn.execute("SELECT id, owner, provider, account_label, status, created_at FROM integrations WHERE id=?", (iid,)).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="Integration not found")
    return dict(id=row[0], owner=row[1], provider=row[2], account_label=row[3], status=row[4], created_at=row[5])

@app.get("/api/integrations/{iid}")
def get_integration(iid: int, user: str = Depends(get_current_user), request: Request = None):
    ip = client_ip(request) if request else ""
    conn = get_db()
    try:
        it = _get_integration(conn, iid)
        _must_be_owner_or_admin(user, it["owner"])
        sec_log("integration_get", "ok", user=user, ip=ip, extra=f"id={iid}")
        return it
    finally:
        conn.close()

@app.post("/api/integrations/{iid}/rotate")
def rotate_integration(iid: int, body: IntegrationRotate, user: str = Depends(get_current_user), request: Request = None):
    ip = client_ip(request) if request else ""
    if not body.token:
        raise HTTPException(status_code=400, detail="Missing token")
    conn = get_db()
    try:
        it = _get_integration(conn, iid)
        _must_be_owner_or_admin(user, it["owner"])
        now = datetime.utcnow().isoformat()+"Z"
        conn.execute("UPDATE integration_secrets SET secret_enc=?, updated_at=? WHERE integration_id=?", (enc_token(body.token), now, iid))
        conn.commit()
        sec_log("integration_rotate", "ok", user=user, ip=ip, extra=f"id={iid}")
        return {"ok": True}
    finally:
        conn.close()

@app.post("/api/integrations/{iid}/test")
def test_integration(iid: int, user: str = Depends(get_current_user), request: Request = None):
    # Mock: no futuro chamaremos o provider. Por ora, valida que existe secret.
    ip = client_ip(request) if request else ""
    conn = get_db()
    try:
        it = _get_integration(conn, iid)
        _must_be_owner_or_admin(user, it["owner"])
        row = conn.execute("SELECT secret_enc FROM integration_secrets WHERE integration_id=?", (iid,)).fetchone()
        if not row:
            raise HTTPException(status_code=500, detail="Secret missing")
        try:
            plain = dec_token(row[0])
            ok = True if plain else False
        except Exception:
            ok = False
        sec_log("integration_test", "ok" if ok else "invalid", user=user, ip=ip, extra=f"id={iid}")
        return {"ok": ok}
    finally:
        conn.close()

@app.delete("/api/integrations/{iid}")
def delete_integration(iid: int, user: str = Depends(get_current_user), request: Request = None):
    ip = client_ip(request) if request else ""
    conn = get_db()
    try:
        it = _get_integration(conn, iid)
        _must_be_owner_or_admin(user, it["owner"])
        conn.execute("DELETE FROM integration_secrets WHERE integration_id=?", (iid,))
        conn.execute("DELETE FROM integrations WHERE id=?", (iid,))
        conn.commit()
        sec_log("integration_delete", "ok", user=user, ip=ip, extra=f"id={iid}")
        return {"ok": True}
    finally:
        conn.close()

# ------------------------ Misc -----------------------
@app.post("/api/setup/admin_once")
def admin_once(body: SeedAdminIn):
    if not DEV_ALLOW_SEED_ADMIN:
        raise HTTPException(status_code=403, detail="Seed admin disabled")
    conn = get_db()
    try:
        has_admin = conn.execute("SELECT 1 FROM users WHERE role='admin' LIMIT 1").fetchone()
        if has_admin:
            raise HTTPException(status_code=400, detail="Admin already exists")
        u = body.username.strip()
        if not u:
            raise HTTPException(status_code=400, detail="username required")
        updated = conn.execute("UPDATE users SET role='admin' WHERE username=?", (u,)).rowcount
        conn.commit()
        if updated == 0:
            raise HTTPException(status_code=404, detail="username not found")
        return {"ok": True, "admin": u}
    finally:
        conn.close()

@app.post("/api/logout")
def api_logout():
    return {"ok": True}

@app.get("/api/healthz")
def healthz():
    return {"ok": True}


import os, time, base64, hashlib, secrets
from urllib.parse import urlencode
from fastapi import APIRouter, Request
from fastapi.responses import RedirectResponse, JSONResponse
import httpx

router = APIRouter(prefix="/api/oauth/google", tags=["oauth-google"])

# Sessões in-memory (dev). TTL curto.
_SESS = {}        # para state->verifier (start->callback)
_SSO_SESS = {}    # para sid-> { profile, tokens, ts }
_TTL = 10 * 60    # 10min

def _b64url(b: bytes) -> str:
    return base64.urlsafe_b64encode(b).rstrip(b"=").decode("ascii")

def _pkce_verifier() -> str:
    # 43–128 chars; usamos 64
    return _b64url(secrets.token_bytes(64))

def _pkce_challenge(verifier: str) -> str:
    import hashlib
    digest = hashlib.sha256(verifier.encode("ascii")).digest()
    return _b64url(digest)

def _gc():
    now = time.time()
    for k, v in list(_SESS.items()):
        if now - v["ts"] > _TTL:
            _SESS.pop(k, None)
    for k, v in list(_SSO_SESS.items()):
        if now - v["ts"] > _TTL:
            _SSO_SESS.pop(k, None)

@router.post("/start")
async def oauth_start():
    _gc()
    cid = os.environ.get("GOOGLE_CLIENT_ID")
    redir = os.environ.get("GOOGLE_REDIRECT_URI")
    scopes = os.environ.get("GOOGLE_SCOPES", "openid email profile https://www.googleapis.com/auth/youtube.readonly")
    if not cid or not redir:
        return JSONResponse({"error":"missing_env","msg":"GOOGLE_CLIENT_ID/REDIRECT_URI ausentes"}, status_code=500)

    state = secrets.token_urlsafe(24)
    verifier = _pkce_verifier()
    challenge = _pkce_challenge(verifier)

    _SESS[state] = {"verifier": verifier, "ts": time.time()}

    q = {
        "client_id": cid,
        "redirect_uri": redir,
        "response_type": "code",
        "scope": scopes,
        "state": state,
        "code_challenge": challenge,
        "code_challenge_method": "S256",
        "include_granted_scopes": "true",
        "access_type": "offline",
        "prompt": "consent",
    }
    url = "https://accounts.google.com/o/oauth2/v2/auth?" + urlencode(q)
    return JSONResponse({"url": url})

@router.get("/callback")
async def oauth_callback(request: Request):
    _gc()
    params = dict(request.query_params)
    error = params.get("error")
    if error:
        return RedirectResponse(f"/web/login.html#sso=google&error={error}")

    code = params.get("code")
    state = params.get("state")
    if not code or not state:
        return RedirectResponse("/web/login.html#sso=google&error=missing_code_or_state")

    sess = _SESS.pop(state, None)
    if not sess or (time.time() - sess["ts"] > _TTL):
        return RedirectResponse("/web/login.html#sso=google&error=state_expired")

    cid = os.environ.get("GOOGLE_CLIENT_ID")
    csec = os.environ.get("GOOGLE_CLIENT_SECRET")
    redir = os.environ.get("GOOGLE_REDIRECT_URI")
    if not cid or not csec or not redir:
        return RedirectResponse("/web/login.html#sso=google&error=server_env")

    data = {
        "client_id": cid,
        "client_secret": csec,
        "code": code,
        "code_verifier": sess["verifier"],
        "grant_type": "authorization_code",
        "redirect_uri": redir,
    }
    async with httpx.AsyncClient(timeout=25) as client:
        r = await client.post("https://oauth2.googleapis.com/token", data=data)
        if r.status_code != 200:
            return RedirectResponse(f"/web/login.html#sso=google&error=token_exchange_{r.status_code}")
        tokens = r.json()
        access_token = tokens.get("access_token")
        if not access_token:
            return RedirectResponse("/web/login.html#sso=google&error=missing_access_token")

        # userinfo OIDC
        ur = await client.get(
            "https://openidconnect.googleapis.com/v1/userinfo",
            headers={"Authorization": f"Bearer {access_token}"},
        )
        if ur.status_code != 200:
            return RedirectResponse(f"/web/login.html#sso=google&error=userinfo_{ur.status_code}")
        ui = ur.json()
        profile = {
            "provider": "google",
            "sub": ui.get("sub"),
            "email": ui.get("email"),
            "email_verified": ui.get("email_verified"),
            "name": ui.get("name"),
            "given_name": ui.get("given_name"),
            "family_name": ui.get("family_name"),
            "picture": ui.get("picture"),
        }

    # cria sid para tela de cadastro (dev: memória)
    sid = secrets.token_urlsafe(18)
    _SSO_SESS[sid] = {"profile": profile, "tokens": tokens, "ts": time.time()}

    success = os.environ.get("OAUTH_SUCCESS_REDIRECT", "/web/register.html")
    sep = "&" if "?" in success else "?"
    return RedirectResponse(f"{success}{sep}sid={sid}")

@router.get("/session/{sid}")
async def get_session(sid: str):
    _gc()
    s = _SSO_SESS.get(sid)
    if not s:
        return JSONResponse({"error":"expired_or_not_found"}, status_code=404)
    # não devolvemos tokens no front
    return {"ok": True, "sid": sid, "profile": s["profile"]}

@router.delete("/session/{sid}")
async def delete_session(sid: str):
    _SSO_SESS.pop(sid, None)
    return {"ok": True}

@router.post("/session/{sid}/finalize")
async def finalize_session(sid: str, req: Request):
    """
    Próxima etapa real: criar usuário no DB e vincular integração.
    Por ora, apenas confirma e remove a sessão.
    """
    s = _SSO_SESS.pop(sid, None)
    if not s:
        return JSONResponse({"error":"expired_or_not_found"}, status_code=404)
    body = await req.json()
    # username, name, email (do body) — validações ficarão na etapa DB
    return {"ok": True, "username": body.get("username"), "email": body.get("email")}

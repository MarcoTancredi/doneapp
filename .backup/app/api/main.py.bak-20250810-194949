
from __future__ import annotations
import os, sqlite3, time
from collections import deque
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Optional, Deque, Dict

from fastapi import FastAPI, HTTPException, Depends, Request, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
from passlib.hash import bcrypt
import jwt
from dotenv import load_dotenv

# ------------------------ Config ------------------------
load_dotenv()

BASE_DIR = Path(__file__).resolve().parents[2]
DATA_DIR = BASE_DIR / "data"
DB_PATH  = DATA_DIR / "app.db"
SEC_LOG  = DATA_DIR / "security.log"
DATA_DIR.mkdir(parents=True, exist_ok=True)

SECRET_KEY = os.getenv("FASTAPI_SECRET", os.getenv("FASTAPI_SECRET_KEY", "CHANGE-ME-SECRET"))
ALGO = "HS256"
def _int(env, default):
    try: return int(os.getenv(env, str(default)))
    except: return default
ACCESS_TOKEN_EXPIRE_HOURS = _int("ACCESS_TOKEN_EXPIRE_HOURS", 8)
REFRESH_TOKEN_EXPIRE_DAYS = _int("REFRESH_TOKEN_EXPIRE_DAYS", 7)
DEV_ALLOW_SEED_ADMIN = os.getenv("DEV_ALLOW_SEED_ADMIN", "false").lower() in ("1","true","yes","on")
DEV_SHOW_RESET_TOKEN = os.getenv("DEV_SHOW_RESET_TOKEN", "false").lower() in ("1","true","yes","on")
SECURITY_LOG_ENABLE  = os.getenv("SECURITY_LOG_ENABLE", "true").lower() in ("1","true","yes","on")

RL_LOGIN_MAX   = _int("RATE_LIMIT_LOGIN_ATTEMPTS",   5)
RL_LOGIN_WIN   = _int("RATE_LIMIT_LOGIN_WINDOW_SEC", 300)
RL_SIGNUP_MAX  = _int("RATE_LIMIT_SIGNUP_ATTEMPTS",  10)
RL_SIGNUP_WIN  = _int("RATE_LIMIT_SIGNUP_WINDOW_SEC",3600)
RL_RESET_MAX   = _int("RATE_LIMIT_RESET_ATTEMPTS",   5)
RL_RESET_WIN   = _int("RATE_LIMIT_RESET_WINDOW_SEC", 300)

# ------------------------ App --------------------------
app = FastAPI(title="DoneApp API", openapi_url="/api/openapi.json", docs_url="/api/docs")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

WEB_DIR = BASE_DIR / "app" / "web"
WEB_DIR.mkdir(parents=True, exist_ok=True)
app.mount("/web", StaticFiles(directory=str(WEB_DIR), html=True), name="web")

@app.get("/", include_in_schema=False)
def root_index():
    return FileResponse(WEB_DIR / "index.html")

# ------------------------ DB ---------------------------
def get_db() -> sqlite3.Connection:
    conn = sqlite3.connect(str(DB_PATH))
    conn.execute("PRAGMA foreign_keys = ON")
    return conn

def init_db():
    conn = get_db()
    try:
        conn.executescript("""
        CREATE TABLE IF NOT EXISTS users (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          username TEXT UNIQUE NOT NULL,
          password_hash TEXT NOT NULL,
          created_at TEXT NOT NULL,
          role TEXT NOT NULL DEFAULT 'user'
        );
        """)
        conn.commit()
    finally:
        conn.close()

def run_migrations():
    conn = get_db()
    try:
        cols = {r[1] for r in conn.execute("PRAGMA table_info(users)").fetchall()}
        if "role" not in cols:
            conn.execute("ALTER TABLE users ADD COLUMN role TEXT NOT NULL DEFAULT 'user'")
            conn.commit()
    finally:
        conn.close()

init_db()
run_migrations()

# ------------------------ Schemas ----------------------
class SignUp(BaseModel):
    username: str
    password: str

class Login(BaseModel):
    username: str
    password: str

class RefreshIn(BaseModel):
    refresh_token: str

class ChangePasswordIn(BaseModel):
    current_password: str
    new_password: str

class SeedAdminIn(BaseModel):
    username: str

class ResetRequestIn(BaseModel):
    username: str

class ResetConfirmIn(BaseModel):
    token: str
    new_password: str

# ------------------------ Security utils -----------------
# in-memory rate limiting (por processo). Em prod: trocar por Redis.
_RL_BUCKETS: Dict[str, Deque[float]] = {}

def client_ip(req: Request) -> str:
    xf = (req.headers.get("x-forwarded-for") or "").split(",")[0].strip()
    if xf: return xf
    return req.client.host if req.client else "unknown"

def rate_limit(key: str, max_attempts: int, window_sec: int) -> Optional[int]:
    """Retorna None se OK; ou segundos de espera se bloqueado."""
    now = time.time()
    dq = _RL_BUCKETS.setdefault(key, deque())
    # limpa janelas antigas
    while dq and now - dq[0] > window_sec:
        dq.popleft()
    if len(dq) >= max_attempts:
        retry_after = int(window_sec - (now - dq[0])) + 1
        return max(1, retry_after)
    dq.append(now)
    return None

def sec_log(action: str, status: str, user: str = "", ip: str = "", extra: str = ""):
    if not SECURITY_LOG_ENABLE: return
    try:
        with SEC_LOG.open("a", encoding="utf-8") as f:
            ts = datetime.utcnow().isoformat() + "Z"
            line = f"{ts} action={action} status={status} user={user} ip={ip} {extra}\n"
            f.write(line)
    except Exception:
        pass

# ------------------------ Auth helpers -----------------
def create_access_token(sub: str, role: str, expires: Optional[timedelta] = None) -> str:
    now = datetime.now(timezone.utc)
    exp = now + (expires or timedelta(hours=ACCESS_TOKEN_EXPIRE_HOURS))
    payload = {"sub": sub, "role": role, "type": "access", "iat": int(now.timestamp()), "exp": int(exp.timestamp())}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGO)

def create_refresh_token(sub: str) -> str:
    now = datetime.now(timezone.utc)
    exp = now + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    payload = {"sub": sub, "type": "refresh", "iat": int(now.timestamp()), "exp": int(exp.timestamp())}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGO)

def create_reset_token(sub: str) -> str:
    now = datetime.now(timezone.utc)
    exp = now + timedelta(minutes=30)
    payload = {"sub": sub, "type": "reset", "iat": int(now.timestamp()), "exp": int(exp.timestamp())}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGO)

def verify_password(pw: str, pw_hash: str) -> bool:
    try: return bcrypt.verify(pw, pw_hash)
    except: return False

def get_current_user(request: Request) -> str:
    auth = request.headers.get("Authorization") or ""
    if not auth.lower().startswith("bearer "):
        raise HTTPException(status_code=401, detail="Missing token")
    token = auth.split(" ",1)[1].strip()
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGO])
        if payload.get("type") != "access":
            raise HTTPException(status_code=401, detail="Invalid token type")
        sub = payload.get("sub")
        if not sub: raise HTTPException(status_code=401, detail="Invalid token payload")
        return str(sub)
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except Exception:
        raise HTTPException(status_code=401, detail="Invalid token")

def require_admin(user: str = Depends(get_current_user)) -> str:
    conn = get_db()
    try:
        row = conn.execute("SELECT role FROM users WHERE username=?", (user,)).fetchone()
        role = row[0] if row else "user"
        if role != "admin":
            raise HTTPException(status_code=403, detail="Admin only")
        return user
    finally:
        conn.close()

# ------------------------ Routes -----------------------
@app.post("/api/signup")
def api_signup(body: SignUp, request: Request):
    ip = client_ip(request)
    key = f"signup:{ip}"
    ra = rate_limit(key, RL_SIGNUP_MAX, RL_SIGNUP_WIN)
    if ra:
        sec_log("signup_rate_limited", "blocked", ip=ip)
        raise HTTPException(status_code=429, detail="Too many signup attempts", headers={"Retry-After": str(ra)})

    if not body.username or not body.password:
        raise HTTPException(status_code=400, detail="Missing username/password")
    conn = get_db()
    try:
        pw_hash = bcrypt.hash(body.password)
        conn.execute(
            "INSERT INTO users (username, password_hash, created_at) VALUES (?, ?, ?)",
            (body.username, pw_hash, datetime.utcnow().isoformat()+"Z"),
        )
        conn.commit()
        sec_log("signup", "ok", user=body.username, ip=ip)
        return {"ok": True}
    except sqlite3.IntegrityError:
        sec_log("signup", "username_taken", user=body.username, ip=ip)
        raise HTTPException(status_code=400, detail="Username already exists")
    finally:
        conn.close()

@app.post("/api/login")
def api_login(body: Login, request: Request):
    ip = client_ip(request)
    key = f"login:{ip}"
    ra = rate_limit(key, RL_LOGIN_MAX, RL_LOGIN_WIN)
    if ra:
        sec_log("login_rate_limited", "blocked", user=body.username, ip=ip)
        raise HTTPException(status_code=429, detail="Too many login attempts", headers={"Retry-After": str(ra)})

    conn = get_db()
    try:
        row = conn.execute("SELECT password_hash, role FROM users WHERE username = ?", (body.username,)).fetchone()
        if not row or not verify_password(body.password, row[0]):
            sec_log("login", "invalid", user=body.username, ip=ip)
            raise HTTPException(status_code=401, detail="Invalid credentials")
        role = row[1] or "user"
        access  = create_access_token(sub=body.username, role=role)
        refresh = create_refresh_token(sub=body.username)
        sec_log("login", "ok", user=body.username, ip=ip, extra=f"role={role}")
        return {"access_token": access, "refresh_token": refresh, "token_type": "bearer", "role": role}
    finally:
        conn.close()

@app.post("/api/token/refresh")
def token_refresh(body: RefreshIn):
    try:
        payload = jwt.decode(body.refresh_token, SECRET_KEY, algorithms=[ALGO])
        if payload.get("type") != "refresh":
            raise HTTPException(status_code=401, detail="Invalid token type")
        sub = str(payload.get("sub") or "")
        if not sub: raise HTTPException(status_code=401, detail="Invalid refresh token")
        conn = get_db()
        try:
            row = conn.execute("SELECT role FROM users WHERE username=?", (sub,)).fetchone()
            role = (row[0] if row else "user")
        finally:
            conn.close()
        return {"access_token": create_access_token(sub=sub, role=role), "token_type": "bearer"}
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Refresh token expired")
    except Exception:
        raise HTTPException(status_code=401, detail="Invalid refresh token")

@app.post("/api/reset/request")
def reset_request(body: ResetRequestIn, request: Request):
    ip = client_ip(request)
    key = f"reset:{ip}"
    ra = rate_limit(key, RL_RESET_MAX, RL_RESET_WIN)
    if ra:
        sec_log("reset_request_rate_limited", "blocked", user=body.username, ip=ip)
        raise HTTPException(status_code=429, detail="Too many reset attempts", headers={"Retry-After": str(ra)})

    user = body.username.strip()
    if not user:
        raise HTTPException(status_code=400, detail="username required")
    conn = get_db()
    try:
        row = conn.execute("SELECT 1 FROM users WHERE username=?", (user,)).fetchone()
        if not row:
            sec_log("reset_request", "unknown_user", user=user, ip=ip)
            return {"ok": True}
    finally:
        conn.close()
    token = create_reset_token(sub=user)
    sec_log("reset_request", "ok", user=user, ip=ip)
    if DEV_SHOW_RESET_TOKEN:
        return {"ok": True, "reset_token": token}
    return {"ok": True}

@app.post("/api/reset/confirm")
def reset_confirm(body: ResetConfirmIn, request: Request):
    ip = client_ip(request)
    try:
        payload = jwt.decode(body.token, SECRET_KEY, algorithms=[ALGO])
        if payload.get("type") != "reset":
            sec_log("reset_confirm", "bad_type", ip=ip)
            raise HTTPException(status_code=401, detail="Invalid token type")
        user = str(payload.get("sub") or "")
        if not user:
            sec_log("reset_confirm", "no_sub", ip=ip)
            raise HTTPException(status_code=401, detail="Invalid token")
    except jwt.ExpiredSignatureError:
        sec_log("reset_confirm", "expired", ip=ip)
        raise HTTPException(status_code=401, detail="Reset token expired")
    except Exception:
        sec_log("reset_confirm", "invalid", ip=ip)
        raise HTTPException(status_code=401, detail="Invalid reset token")

    if not body.new_password:
        raise HTTPException(status_code=400, detail="new_password required")

    conn = get_db()
    try:
        new_hash = bcrypt.hash(body.new_password)
        updated = conn.execute("UPDATE users SET password_hash=? WHERE username=?", (new_hash, user)).rowcount
        conn.commit()
        if updated == 0:
            sec_log("reset_confirm", "user_not_found", user=user, ip=ip)
            raise HTTPException(status_code=404, detail="User not found")
        sec_log("reset_confirm", "ok", user=user, ip=ip)
        return {"ok": True}
    finally:
        conn.close()

@app.get("/api/me")
def api_me(user: str = Depends(get_current_user)):
    return {"user": user}

@app.get("/api/users/me")
def users_me(user: str = Depends(get_current_user)):
    conn = get_db()
    try:
        row = conn.execute("SELECT username, role, created_at FROM users WHERE username=?", (user,)).fetchone()
        if not row: raise HTTPException(status_code=404, detail="User not found")
        return {"username": row[0], "role": row[1], "created_at": row[2]}
    finally:
        conn.close()

@app.post("/api/change_password")
def change_password(body: ChangePasswordIn, user: str = Depends(get_current_user), request: Request = None):
    conn = get_db()
    try:
        row = conn.execute("SELECT password_hash FROM users WHERE username=?", (user,)).fetchone()
        if not body.current_password or not body.new_password or not row or not verify_password(body.current_password, row[0]):
            if request is not None:
                sec_log("change_password", "invalid_current", user=user, ip=client_ip(request))
            raise HTTPException(status_code=401, detail="Invalid current password")
        new_hash = bcrypt.hash(body.new_password)
        conn.execute("UPDATE users SET password_hash=? WHERE username=?", (new_hash, user))
        conn.commit()
        if request is not None:
            sec_log("change_password", "ok", user=user, ip=client_ip(request))
        return {"ok": True}
    finally:
        conn.close()

@app.get("/api/admin/ping")
def admin_ping(user: str = Depends(require_admin), request: Request = None):
    if request is not None:
        sec_log("admin_ping", "ok", user=user, ip=client_ip(request))
    return {"admin": user, "ok": True}

@app.post("/api/setup/admin_once")
def admin_once(body: SeedAdminIn):
    if not DEV_ALLOW_SEED_ADMIN:
        raise HTTPException(status_code=403, detail="Seed admin disabled")
    conn = get_db()
    try:
        has_admin = conn.execute("SELECT 1 FROM users WHERE role='admin' LIMIT 1").fetchone()
        if has_admin:
            raise HTTPException(status_code=400, detail="Admin already exists")
        u = body.username.strip()
        if not u:
            raise HTTPException(status_code=400, detail="username required")
        updated = conn.execute("UPDATE users SET role='admin' WHERE username=?", (u,)).rowcount
        conn.commit()
        if updated == 0:
            raise HTTPException(status_code=404, detail="username not found")
        return {"ok": True, "admin": u}
    finally:
        conn.close()

@app.post("/api/logout")
def api_logout():
    return {"ok": True}

@app.get("/api/healthz")
def healthz():
    return {"ok": True}

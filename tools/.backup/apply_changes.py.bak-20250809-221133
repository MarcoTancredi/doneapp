# apply_changes.py — servidor Flask para aplicar mudanças por protocolo
# Segurança básica:
#  - Só aceita caminhos dentro de workspace_root
#  - Cria backups (*.bak-YYYYmmdd-HHMMSS) antes de escrever
#  - Ações: FileNew, FileDelete, TextInsert, TextDelete, TextModify

from __future__ import annotations
import re, time, json
from pathlib import Path
from typing import List, Tuple
from flask import Flask, request, jsonify

app = Flask(__name__)

# --- CORS: permitir file:// (updater.html) chamar http://127.0.0.1:5000/apply ---
@app.after_request
def add_cors_headers(resp):
    resp.headers['Access-Control-Allow-Origin'] = '*'
    resp.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    resp.headers['Access-Control-Allow-Methods'] = 'POST, OPTIONS'
    return resp

# Responder ao preflight de forma explícita
@app.route('/apply', methods=['OPTIONS'])
def apply_options():
    return ('', 204)

ACTION_RE = re.compile(r'^#Action:\s*(FileNew|FileDelete|TextInsert|TextDelete|TextModify)\s*$', re.I)
TARGET_RE = re.compile(r'^#Target:\s*(.+?)\s*$')

def _norm_inside(root: Path, target: str) -> Path:
    p = (root / target).resolve()
    if root not in p.parents and p != root:
        raise ValueError(f"Target escapes workspace: {p}")
    return p

def _read_block(lines: List[str], start_marker: str, end_marker: str) -> Tuple[List[str], int]:
    content = []
    i = 0
    while i < len(lines) and lines[i].strip() != start_marker:
        i += 1
    if i == len(lines):
        return [], -1
    i += 1
    while i < len(lines) and lines[i].strip() != end_marker:
        content.append(lines[i].rstrip("\n"))
        i += 1
    if i == len(lines):
        raise ValueError(f"Missing {end_marker}")
    i += 1
    return content, i

def _apply_one_action(action: str, file_path: Path, blocks: List[dict]) -> str:
    log = []
    ts = time.strftime("%Y%m%d-%H%M%S")
    file_path.parent.mkdir(parents=True, exist_ok=True)

    if action == "FileNew":
        if file_path.exists():
            backup = file_path.with_suffix(file_path.suffix + f".bak-{ts}")
            file_path.replace(backup)
            log.append(f"Backup existente: {backup.name}")
        subject = blocks[0]["subject"] if blocks else []
        file_path.write_text("\n".join(subject) + ("\n" if subject else ""), encoding="utf-8")
        return "\n".join(log + [f"FileNew OK: {file_path}"])

    if action == "FileDelete":
        if file_path.exists():
            backup = file_path.with_suffix(file_path.suffix + f".bak-{ts}")
            file_path.replace(backup)
            log.append(f"Backup: {backup.name}")
            return "\n".join(log + [f"FileDelete OK (arquivo movido para backup)"])
        else:
            return "\n".join(log + [f"FileDelete: arquivo não existe ({file_path})"])

    if not file_path.exists():
        raise FileNotFoundError(f"Arquivo não encontrado para ação {action}: {file_path}")

    original = file_path.read_text(encoding="utf-8")
    new_text = original

    for idx, blk in enumerate(blocks, start=1):
        before = "\n".join(blk["before"])
        after  = "\n".join(blk["after"])
        subject= "\n".join(blk["subject"])

        pattern = re.compile(re.escape(before) + r"(.*?)" + re.escape(after), re.DOTALL)
        m = pattern.search(new_text)
        if not m:
            log.append(f"[NÃO ACHADO] Bloco {idx}: {subject[:80]}")
            continue

        if action == "TextInsert":
            replacement = before + subject + after
        elif action == "TextDelete":
            replacement = before + after
        elif action == "TextModify":
            replacement = before + subject + after
        else:
            raise ValueError(f"Ação não suportada: {action}")

        new_text = new_text[:m.start()] + replacement + new_text[m.end():]
        log.append(f"[OK] Bloco {idx}: {subject[:80]}")

    if new_text != original:
        backup = file_path.with_suffix(file_path.suffix + f".bak-{ts}")
        backup.write_text(original, encoding="utf-8")
        file_path.write_text(new_text, encoding="utf-8")
        log.append(f"Backup do original: {backup.name}")
    else:
        log.append("Nenhuma alteração aplicada (âncoras não encontradas).")

    return "\n".join(log)

def parse_protocol(proto_text: str):
    lines = [ln.rstrip("\r\n") for ln in proto_text.splitlines()]
    i = 0
    actions = []
    while i < len(lines):
        line = lines[i].strip()
        if not line:
            i += 1; continue
        m = ACTION_RE.match(line)
        if m:
            action = m.group(1)
            i += 1
            if i >= len(lines) or not TARGET_RE.match(lines[i].strip()):
                raise ValueError("Esperado '#Target:' após '#Action:'")
            target = TARGET_RE.match(lines[i].strip()).group(1)
            i += 1
            blocks = []
            while i < len(lines):
                if lines[i].strip() == "#ActionEnded":
                    i += 1
                    break
                remaining = lines[i:]
                before, offset = _read_block(remaining, "#BeginBeforeLines", "#EndBeforeLines")
                if offset == -1:
                    break
                i += offset
                # ActionText block is optional
                if i < len(lines) and lines[i].strip() == "#BeginActionText":
                    action_text, offset = _read_block(lines[i:], "#BeginActionText", "#EndActionText")
                    i += offset
                else:
                    action_text = []
                after, offset = _read_block(lines[i:], "#BeginAfterLines", "#EndAfterLines")
                i += offset
                subject, offset = _read_block(lines[i:], "#BeginSubject", "#EndSubject")
                i += offset
                blocks.append({"before": before, "action_text": action_text, "after": after, "subject": subject})
            actions.append({"action": action, "target": target, "blocks": blocks})
        else:
            i += 1
    return actions

@app.post("/apply")
def apply_changes():
    data = request.get_json(force=True)
    workspace_root = Path(data.get("workspace_root", ".")).resolve()
    protocol_text = data.get("protocol_text", "")
    out_lines = []

    actions = parse_protocol(protocol_text)
    for a in actions:
        action = a["action"]
        target = a["target"]
        out_lines.append(f"=> Log/print Action File Inicio: {action} {target}")
        try:
            file_path = _norm_inside(workspace_root, target)
            result = _apply_one_action(action, file_path, a["blocks"])
            out_lines.append(result)
        except Exception as e:
            out_lines.append(f"[ERRO] {e}")
        out_lines.append("")
    out = "\n".join(out_lines) if out_lines else "Nada aplicado."
    return jsonify({"ok": True, "output": out})

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Apply protocol changes via HTTP API")
    parser.add_argument("--host", default="127.0.0.1")
    parser.add_argument("--port", default=5000, type=int)
    args = parser.parse_args()
    print(f"* Servindo em http://{args.host}:{args.port}  (POST /apply)")
    app.run(host=args.host, port=args.port)